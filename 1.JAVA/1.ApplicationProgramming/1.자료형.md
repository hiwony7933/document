## 자료형(Data Type)
### 1.java 에서 일반적으로 자료형을 구분하는 방법
1) value type(기본형): 변수가 데이터 자체를 의미하는 것
* 8가지의 자료형이 제공
* boolean, byte, short, char, int, long, float, double

2) reference type(참조형): 변수가 데이터의 참조를 의미하는 것
* 배열, 클래스(객체)

### 2.java에서 변수 선언
* `자료형 변수이름;`
* 기본형인 경우는 이름만 만들어지고 참조형인 경우는 변수이름이 만들어지고 공간할달을 한 후 null을 저장

### 3.변수가 가리키는 공간에 값 대입
`변수이름 = 데이터;`  
* 이 때 데이터는 변수가 선언될 때와 동일한 자료형의 데이터만 가능
* 선언과 동시에 값 할당 가능
`자료형 변수이름 = 데이터;`  

### 4.java는 명령어를 종료할 때 마다 ;을 해야 합니다.

### 5.변수는 선언할 때와 `=`의 왼쪽에 있을 때는 공간을 의미하지만 그 이외의 경우는 데이터나 데이터의 참조를 의미합니다.

```java
int a = 10;   //선언할 때 이므로 a라는 공간
System.out.println(a); //a라는 공간에 저장된 데이터(10)를 출력
a = a + 4; //10이라는 값에 4를 더한 결과를 a라는 공간에 다시 저장
```

### 6.변수의 종류
1) Local Variable(지역변수): 자신을 만든 영역에서만 사용이 가능한 변수
* 메소드(함수) 안에서 만들어진 변수

2) Instance Variable(멤버변수): 자신을 소유하고 있는 객체를 통해서만 접근이 가능한 변수
* 클래스 안에서 static 키워드 없이 메소드 바깥에 선언된 변수

3) Static Variable(클래스변수): 자신을 소유하고 있는 클래스를 통해서 접근이 가능한 변수
* 클래스 안에서 static 이라는 키워드와 함께 메소드 바깥에 선언된 변수
* 자바에서는 이 변수를 이용해서 전역변수(Global Variable - 아무 곳에서나 사용 가능한 변수)를 만듭니다.

### 7.기본형
* 변수가 데이터 자체인 자료형
* boolean : byte, short, char, int, long : float, double

1) boolean
* 참과 거짓을 저장할 수 있는 자료형
* boolean literal: true 와 false
* boolean 자료형은 boolean 만 저장 가능
* 변수를 만들 때 앞에 is를 붙여서 boolean 이라는 것을 나타내는 경우가 많습니다.
* is로 시작하는 모든 것들은 참 과 거짓을 판별하는 것입니다.

* 실습: boolean 변수를 만들고 데이터를 저장한 후 값을 출력해보기
	
```java
//boolean 변수를 만들어서 값을 저장
boolean isNum = false;

//변수의 값을 출력
System.out.println("isNum:" + isNum);
```

2) 정수
* byte(1byte), short(2byte), char(2byte), int(4byte), long(8byte)
* bit(binary digit): 0 또는 1 둘 중에 하나의 데이터를 저장할 수 있는 메모리 크기
* byte: 8비트로 2의 8승 가지를 구별할 수 있는 크기 - 256가지 구분 - 영문 1글자
* 1byte: -128 ~ +127까지 저장, 데이터를 메모리에 저장되는 구조로 저장하기 위해서 사용,
	* 파일의 내용을 저장하거나 네트워크에서 데이터를 주고 받을 때 주로 이용
* short: -32768 ~ 32767 까지 저장, 예전에 좌표 같은 것을 short를 이용해서 저장
* char: 0 ~ 65535까지 저장, 정수를 저장하고 있다가 출력을 할 때는 정수에 해당하는 ASCII 코드에 해당하는 

```
문자를 출력
48 -> '0'
65 -> 'A'
97 -> 'a'
0 -> null
7 -> beep 음
```

* int : 4byte, -21억 ~ +21억까지 표현, 정수의 기준형, 10 이라고 입력을 하면 int 10입니다.
	* 가장 많이 사용되는 정수 자료형

* long: 8byte, 크거나 작은 정수 표현, 리터럴로 표현할 때는 뒤에 L 또는 l 을 붙임
	* 10L 이라고 하면 long 형 정수 10입니다.

* 변수를 만들면 자신이 저장할 수 있는 크기보다 크거나 작은 값은 저장할 수 없습니다.
	* 다른 변수의 데이터를 저장할 때는 자신의 크기와 같거나 작은 자료형의 변수의 값만 저장 가능

> int 에 long을 저장 못함  
> long에 int는 저장 가능  

**크기**  
* byte < short < char < int < long

* 실습
* 
```java
자신의 나이를 저장하고 출력
int age = 50;
System.out.println("나이:" + age);
```

* java에서 하나의 문자 저장
	* 문자 리터럴 표현: '문자' 또는 0x16진수2개 등으로 표현 
	* 자료형은 char에 저장하면 출력할 때 문자로 출력되고 다른 정수 자료형에 저장하면 숫자로 출력

```java
char ch = 'A';
int c = 'A';
System.out.println("ch:" + ch); //char를 출력하므로 A로 출력
System.out.println("c:" + c); //int를 출력하므로 65로 출력
```

3) 실수
* float(4byte): +- 2의 38 승 정도의 데이터 까지 표현, 숫자의 정밀도는 소수 7자리 정도
	*  literal로 표현할 때는 뒤에 소문자 f를 추가
	*  `4.07f` 형태로 표현

* double(8byte) : +- 2의 308 승 정도의 데이터까지 표현, 숫자의 정밀도는 소수 15자리 정도
	* 실수의 기준형은 double 이어서 특별한 문자 없이 표현
	* 3.14 로 입력하면 실제 저장은 +0.314E+002 의 지수 형태로 저장
	* 0.314 * 10의 2승
	* 지수 형태로 저장해야 작은 크기로 넓은 범위의 숫자를 표현할 수 있기 때문입니다.
	* float 을 사용하는 것이 메모리를 절약하는 것이기는 하지만 되도록이면 double을 사용하는 것을 권장하는데 그 이유는 지금의 CPU는 산술 연산을 빠르게 하기 위해서 수치보조 프로세서를 가지고 있는데 이 수치보조 프로세서의 연산 단위가 double 입니다.

* 실수를 가지고 연산할 때는 주의해야 합니다.
	* 실수는 정확하게 표현할 수 없는 경우가 있기 때문입니다.

```java
double i = 0.1;
double sum = 0.0;
for(int j=0; j<1000; j=j+1) {
	sum = sum + i;
}
System.out.println("sum:" + sum); //0.1을 1000번 더했는데 100.0 이 아님
		
System.out.println("1-0.8:" + ((1-0.8)==0.2)); //1-0.8 과 0.2를 비교했는데 다르다고 나옴
```

### 8.Type Casting
* 데이터의 자료형을 변환하는 것

1) 분류
* 자동 형 변환: 데이터의 자료형이 자동으로 변환되는 경우
* 강제 형 변환: 원하는 결과를 만들기 위해서 강제로 자료형을 변환하는 경우

2) 형 변환이 가능한 경우
* 숫자 데이터끼리는 형 변환이 가능합니다.
	* (byte, short, char, int, long, float, double)
* 참조형 데이터의 경우는 상속 관계인 경우만 가능합니다.

3) 자동 형 변환
* 표현할 수 있는 범위가 큰 자료형의 변수에 작은 자료형의 데이터를 대입하는 경우
* long은 8byte 이고 float 은 4byte 이지만 long 은 정수이고 float은 실수라서 float이 표현범위가 long 보다 크기 때문에 float 이 long 보다 큽니다.

```
ex)
float f = 10;
f는 float 변수인데 10이라는 int 형 데이터를 대입했습니다.
float f = 10.0f; 로 변경되서 처리
```

* 정수 자료형의 변수에 int 정수 상수를 대입하면 변수가 표현할 수 있는 범위 내의 숫자라면 그 변수이 자료형으로 변경되서 대입됩니다.
* 리터럴은 변경이되서 저장되지만 변수의 값은 변경이 안되기 때문에 저장이 안됩니다.

```
ex)
short s = 3000; //3000이라는 int 형 리터럴이 short 범위 안에 있는 정수이므로 short로 변경되서 저장이 됩니다.
int n = 3000;
s = n; //n은 int 형 변수이므로 이 데이터의 크기를 줄여서 short 에 대입할 수 없습니다.
```

* 산술연산을 하면 2개의 자료형이 동일할 때는 동일한 자료형으로 결과를 리턴하고 2개의 자료형이 다를 때는 큰 자료형으로 변환해서 연산을 수행
* 그리고 int 보다 작은 자료형으로 산술연산을 하면 int 로 변경해서 산술연산을 수행

정수 / 정수 = 정수;  
10/4 = 2.5가 아니라 2 =>소수는 버림

```java
short s1 = 100;
short s2 = 200;
short s3 = s1 + s2; //에러가 발생합니다.
```

short + short 이지만 자바는 int로 변경해서 연산을 하기 때문에 int + int 가 되서 short에 결과를 저장할 수 없습니다.  

실습) 자동 형 변환

```java
		//자동 형 변환
		double d = 10; //10을 10.0 으로 변환해서 저장
		System.out.printf("d:%f\n",  d);
		
		//숫자의 표현범위가 int 보다 작은 변수에
		//저장 가능한 정수 리터럴를 대입하면 형 변환해서 대입됩니다.
		//표현범위가 더 큰 정수는 대입이 안되고 더 큰 자료형 변수에 있는 데이터도 대입이 안됩니다.
		short s = 3000; //3000이라는 상수는 short 표현 범위 내라서 대입이 가능
		
		//아래 문장은 에러
		//s = 65535; //65535는 short 표현범위 밖이라서 대입이 불가능
		
		int n = 3000;
		//s = n; //같은 3000이지만 변수에 저장된 3000은 int 3000이라서 더 큰 데이터라서
		//역시 에러가 발생합니다.
		
		//자바는 산술연산(+, -, *, /, %)을 할 때 2개의 자료형이 다르면 
		//더 큰 자료형으로 변환해서 연산을 하고 int 보다 작으면 int 로 변환해서 연산
		//2개의 자료형이 같으면 결과도 동일한 자료형으로 리턴
		
		double result = 10 / 3;
		//결과는 3.3 이 아니고 3.0
		//정수 / 정수는 결과가 정수
		System.out.println("result:" + result);
		
		//int 보다 작은 자료형의 연산은 int로 변환해서 처리하기 때문에
		//산술연산의 결과 최소 자료형은 int
		short s1 = 300;
		short s2 = 100;
		short s3 = s1 + s2;
		//위의 구문은 에러
		//short + short 이지만 결과는 int
		//산술 연산의 최소단위는 int
		//cpu 의 정수 최소 처리 단위가 int
```

4) 강제 형 변환
* 데이터의 자료형을 강제로 변경하는 것
* 숫자 데이터끼리 변환이 가능하고 참조형인 경우는 상속 관계인 경우만 가능
* 숫자 데이터의 형변환을 하는 경우는 원하는 결과를 만들기 위해서 또는 큰 자료형의 데이터를 작은 자료형의 데이터로 변환하기 위해서 입니다.
* 방법
`(변환할 자료형)데이터`  

* 데이터라고 할 때는 변수와 상수 모두 그리고 변수만 가능할 때는 변수라고 기재
* 실수를 정수로 변환하면 소수는 버려지게 됩니다.

```
ex) 정수 / 정수를 할 때 소수까지 결과를 저장하고 싶은 경우
double result = 10 / 7;		// 이렇게 하면 결과는 1.0

double result = (double)10 / 7;
// 10을 double로 변환해서 10.0 / 7을 만들게 되고
// 실수와 정수가 연산을 정수를 실수로 변환해서 10.0 /7.0 이 되고 그러면 결과는 1.4....

// 실수 / 실수를 했을 때 몫만 취하고자 하는 경우

int r = 10.3 / 5.2; // 에러 - 실수 / 실수 이므로 결과는 실수인데 int에 저장할려고 해서 에러

int r = (int)(10.3 / 5.2); // 결과를 정수로 강제로 형 변환을 해서 1로 만들어서 r에 대입합니다.
```

### 9.Overflow & Underflow
1) Overflow: 숫자 자료형에서 자신이 저장할 수 있는 크기보다 큰 데이터를 강제 형 변환해서 데이터를 저장하는 경우 자신이 저장할 수 범위까지의 데이터만 저장하고 앞쪽의 데이터는 제거하고 저장하는 경우

```java
short: 2byte 정수로 -32768 ~ +32767 범위 내의 숫자만 저장 가능
short s = 32768; //이 구문은 에러 
32768 -> 0 10000000 00000000
표현범위가 큰 데이터를 작은 범위의 변수에 저장하기 위해서는 강제 형 변환이 필요
short s = (short)32768;
short s = 10000000 00000000(2진수);

System.out.println("s:" + s); //-32768
```

* 자신이 저장할 수 있는 데이터보다 더 큰 숫자를 저장하면 가장 숫자부터 다시 시작

2) underflow
* 자신이 저장할 수 있는 숫자보다 더 작은 숫자를 저장하면 가장 큰 숫자부터 다시 시작

3) 숫자 데이터의 연산에서 결과 자료형보다 더 크거나 작은 데이터가 나오게 되면 잘못된 결과를 만들 수 있습니다.

4) 실습

```java
		//short에 32767 보다 큰 숫자는 그냥은 저장 안됨
		//강제 형 변환을 통해서만 저장됨
		//16비트 앞쪽의 비트는 잘리게 됨 - Overflow
		//가장 작은 숫자부터 다시 시작 - 음수가 저장됨
		//반대되는 현상을 Underflow 라고 합니다.
		short s = (short)32768;

		//저장된 데이터를 출력
		System.out.println("s:" + s);
```

### 10.문자열
* String 이라는 클래스를 이용해서 문자열을 저장
* 문자열을 대입할 때는 클래스에서는 예외적으로 직접 값 대입이 가능
`String 변수명 = "문자열";` 의 형태로 생성 가능  

* 문자열 과 숫자 데이터 또는 boolean 을 + 연산하게 되면 숫자 데이터와  boolean을 문자열로 변환해서 결합을 합니다.

### 11.Literal 저장
* Literal: 사용자가 직접 작성한 데이터

	* boolean 리터럴: true, false
	* 정수 리터럴: 10(int), 10L(long)
	* 실수 리터럴: 3.2f(float), 3.2(double), 0.314E+001(3.14 -> 0.314 * 10의 1승)
	* 문자 리터럴: 'A'
	* 문자열 리터럴: "ABC", "A"
	* 참조 리터럴: null(가리키는 참조가 없다. 결측치)

* Literal은 영구적인 영역에 저장
	* 한 번 만들어지면 프로그램이 종료될 때 까지 소멸되지 않습니다.
	* Literal을 변수에 저장하면 먼저 메모리 영역에서 있는지 찾아보고 찾으면 그 참조를 저장하고 찾지 못하면 Literal을 메모리에 저장하고 그 참조를 저장합니다.

* 자바에서는 변수가 참조하고 있는 영역을 확인하고자 할 때 System.identityHashCode 메소드에 변수를 대입해서 출력해보면 됩니다.

실습: 3개의 정수를 저장할 수 있는 변수를 만들고 2개에는 동일한 값을 저장하고 다른 1개에는 다른 값을 저장한 후 해시코드를 출력

```java
		int a = 10;
		int b = 10;
		int c = 11;
		//a와 b는 동일한 데이터를 저장했기 때문에 해시코드가 동일
		//c는 다른 데이터를 저장했기 때문에 다른 해시코드를 출력
		System.out.println("a:" + System.identityHashCode(a));
		System.out.println("b:" + System.identityHashCode(b));
		System.out.println("c:" + System.identityHashCode(c));
```

### 12.System.out.printf
* 서식에 맞춰서 콘솔에 출력해주는 메소드
* 프린터 같은 장비는 GUI(윈도우) 운영체제를 탑재하지 않고 CLI(Command Line Interface) 기반의 운영체제를 탑재하고 있는데 이런 운영체제에 데이터를 출력할 때는 서식을 이용해서 출력을 해야 데이터에 맞춤을 적용해서 출력할 수 있습니다.
* java 에서는 이 경우 printf 메소드를 이용합니다.

1) 사용방법
`System.out.printf("서식 나열", 서식에 매핑되는 데이터를 나열);`
* 서식은 반드시 %로 시작

2) 서식
* 정수 : `%d`, `%i` 
* 실수: `%f`
* 문자: `%c`
* 문자열: `%s`
* boolean: `%b`

3) `%`다음에 숫자를 입력하면 숫자만큼의 자리를 확보해서 출력

4) `%0`숫자 형태로 입력하면 빈자리는 0으로 채워집니다.

5) 실수의 경우 `%전체자릿수.소수자릿수f` 형태로 출력할 소수 자릿수를 설정할 수 있는데 소수 자릿수 아래에서 반올림

6) `String.format` 가 사용방법이 동일
* `String.format`은 출력하지 않고 문자열로 리턴합니다.

```java
int age = 20;
double height = 176.53;
System.out.printf("나이는 %d 키는 %.1f 입니다.", age, height);
```


